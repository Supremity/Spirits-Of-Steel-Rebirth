extends Node

signal player_stats_changed()
signal player_country_changed()
var countries: Dictionary = {}
var player_country: CountryData

func _ready() -> void:
	
	await get_tree().process_frame
	if MainClock:
		MainClock.connect("day_passed", Callable(self, "_on_day_passed"))


func _on_day_passed(day, month, year) -> void:
	# Loop through every country instance in the dictionary
	for c_name in countries:
		var country_obj: CountryData = countries[c_name]
		country_obj.process_turn()
	emit_signal("player_stats_changed")

func initialize_countries() -> void:
	countries.clear()
	
	# 1. Get the list of countries generated by MapManager
	# MapManager.country_to_provinces keys are the valid countries found on the map image
	var detected_countries = MapManager.country_to_provinces.keys()
	
	if detected_countries.is_empty():
		push_warning("CountryManager: No countries detected in MapManager!")
		# Fallback to the colors list if map generation failed or is empty
		detected_countries = MapManager.COUNTRY_COLORS.keys()

	# 2. Create a CountryData instance for each
	for country_name in detected_countries:
		create_country(country_name)
		
	print("CountryManager: Initialized %d countries." % countries.size())

func create_country(c_name: String) -> void:
	# Create the instance
	var new_country = CountryData.new(c_name)
	
	# Add it as a child of this Manager so it stays in the scene tree
	# (This ensures it receives processing if you add _process later, and keeps memory safe)
	add_child(new_country)
	
	# Store in dictionary
	countries[c_name] = new_country

# --- API to access data ---

func get_country(c_name: String) -> CountryData:
	c_name = c_name.to_lower()
	if countries.has(c_name):
		return countries[c_name]
	push_error("CountryManager: Requested non-existent country '%s'" % c_name)
	return null

func set_player_country(c_name: String) -> void:
	var c = get_country(c_name)
	if c:
		player_country = c
		print("Player is now playing as: ", c_name)
	emit_signal("player_country_changed")
